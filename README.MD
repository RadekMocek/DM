# AnalÃ½za nÃ¡kupnÃ­ho koÅ¡Ã­ku

## PorozumÄ›nÃ­ problÃ©mu

ObchodnÃ­ Å™etÄ›zec potÅ™ebuje analyzovat nakupovacÃ­ nÃ¡vyky svÃ½ch zÃ¡kaznÃ­kÅ¯, aby mohl provÃ¡dÄ›t cÃ­lenÃ© nabÃ­dky urÄitÃ©ho typu zboÅ¾Ã­. Ãšloha mÃ¡ dva cÃ­le: vytvoÅ™it akci na prodej konkrÃ©tnÃ­ho zboÅ¾Ã­ (nabÃ­dnout Äi nenabÃ­dnout â€“ v naÅ¡em pÅ™Ã­padÄ› se jednÃ¡ o zboÅ¾Ã­ typu alkohol) a vytvoÅ™it obecnÃ© doporuÄenÃ­, jakÃ© zboÅ¾Ã­ zÃ¡kaznÃ­kovi jeÅ¡tÄ› nabÃ­dnout.

Soubor `Shopping_items.sav` pÅ™edstavuje transakÄnÃ­ data vznikajÃ­cÃ­ pÅ™i prÅ¯chodu zÃ¡kaznÃ­ka pokladnou. DatovÃ¡ matice obsahuje promÄ›nnÃ© `ID` a `ITEM`. `ID` je identifikÃ¡tor jednoho konkrÃ©tnÃ­ho nÃ¡kupu a `ITEM` je druh zboÅ¾Ã­, kterÃ½ byl souÄÃ¡stÃ­ tohoto nÃ¡kupu. VstupnÃ­ data jsou zjednoduÅ¡ena tÃ­m, Å¾e zboÅ¾Ã­ je jiÅ¾ zaÅ™azeno do produktovÃ½ch skupin.

![NÃ¡hled na vstupnÃ­ data](./img/ShoppingItemsPreview.png)

## PrvnÃ­ spuÅ¡tÄ›nÃ­ projektu

V koÅ™enovÃ©m adresÃ¡Å™i projektu otevÅ™ete PowerShell a spusÅ¥te nÃ¡sledujÃ­cÃ­ pÅ™Ã­kazy:

```ps1
# 1. VytvoÅ™enÃ­ virtuÃ¡lnÃ­ho prostÅ™edÃ­
py -m venv .venv

# 2. Aktivace virtuÃ¡lnÃ­ho prostÅ™edÃ­
.venv\Scripts\activate

# 3. NainstalovÃ¡nÃ­ potÅ™ebnÃ½ch zÃ¡vislostÃ­
py -m pip install -r requirements.txt

# 4. SpuÅ¡tÄ›nÃ­ aplikace Jupyter Notebook v adresÃ¡Å™i s notebookem
jupyter notebook --notebook-dir=./notebook
```

Po naÄtenÃ­ uÅ¾ivatelskÃ©ho rozhranÃ­ aplikace Jupyter Notebook kliknÄ›te na soubor _alza.ipynb_.

PrÃ¡ce ve virtuÃ¡lnÃ­m prostÅ™edÃ­ je alespoÅˆ na mÃ©m PC ponÄ›kud pomalejÅ¡Ã­ (pomalejÅ¡Ã­ instalace balÃ­kÅ¯, pomalÃ© naÄÃ­tÃ¡nÃ­ grafÅ¯, ...). Pokud vÃ¡m nevadÃ­ globÃ¡lnÃ­ instalace balÃ­kÅ¯, pak staÄÃ­ dvojice pÅ™Ã­kazÅ¯ `pip install -r requirements.txt` a `jupyter notebook --notebook-dir=./notebook`.

## Import zÃ¡vislostÃ­

Pro realizaci zadÃ¡nÃ­ je pouÅ¾ita knihovna _pandas_. Do jejÃ­ datovÃ© struktury zvanÃ© _DataFrame_ naÄteme data ze vstupnÃ­ho souboru `Shopping_items.sav` (balÃ­kem _pyreadstat_) a budeme na nÃ­ provÃ¡dÄ›t operace jako na datovÃ© matici v Modeleru.

Pro vizualizaci dat je pouÅ¾ita kombinace _hvplot_ + _bokeh_. JednÃ­m z vykreslovanÃ½ch grafÅ¯ je tzv. pavuÄinovÃ½ diagram (_Graphs â†’ Web_ v Modeleru, omluvte mnou obÄas pouÅ¾Ã­vanÃ½ kratÅ¡Ã­ vÃ½raz â€pavuÄiÅˆÃ¡kâ€œ), kterÃ½ ale Å¾Ã¡dnÃ¡ mnou zkoumanÃ¡ knihovna nativnÄ› nepodporuje. Pro jeho vlastnÃ­ implementaci je proto pouÅ¾ita knihovna _networkx_.

ModelovacÃ­ algoritmus Apriori je obsaÅ¾en v balÃ­ku _mlxtend_.

```py
import itertools  # VytvoÅ™enÃ­ kombinacÃ­, pomÅ¯Å¾e pÅ™i tvorbÄ› pavuÄiÅˆÃ¡ku
import pathlib    # K souboru .sav se dostaneme relativnÃ­ cestou

import hvplot.networkx as hvnx  # PavuÄiÅˆÃ¡k
import networkx as nx           # PavuÄiÅˆÃ¡k
import pandas as pd             # PrÃ¡ce s datovou maticÃ­ â€“ datovÃ¡ analÃ½za v Pythonu
import pyreadstat               # ÄŒtenÃ­ .sav souboru
from mlxtend.frequent_patterns import apriori, association_rules

pd.options.plotting.backend = "hvplot"  # NamÃ­sto matplotlib pouÅ¾Ã­vÃ¡me hvplot + bokeh
```

## PorozumÄ›nÃ­ datÅ¯m

TransakÄnÃ­ data je nejrpve nutnÃ© naÄÃ­st, k tomu pouÅ¾ijeme balÃ­k _pyreadstat_. NeÅ¾ se vrhneme na samotnou datovou matici v podobÄ› _pandas DataFrame_, mÅ¯Å¾eme vyÄÃ­st z metadat, Å¾e mÃ¡me na vstupu 2395 Å™Ã¡dkÅ¯ a dva sloupce: `ID` a `ITEM`.

```py
# == NalezenÃ­ a naÄtenÃ­ SPSS dat. DostÃ¡vÃ¡me pandas DataFrame a metadata. ==
PATH = pathlib.Path()
PATH_SHOPPING_ITEMS = PATH / ".." / "data" / "Shopping_items.sav"
df, meta = pyreadstat.read_sav(PATH_SHOPPING_ITEMS)
print(type(df))
# <class 'pandas.core.frame.DataFrame'>
print(type(meta))
# <class 'pyreadstat._readstat_parser.metadata_container'>

# == UÅ¾iteÄnÃ¡ metadata ==
print("PoÄet Å™Ã¡dkÅ¯:\t", meta.number_rows)
# PoÄet Å™Ã¡dkÅ¯:   2395
print("PoÄet sloupcÅ¯:\t", meta.number_columns, "... konkrÃ©tnÄ›:", meta.column_names)
# PoÄet sloupcÅ¯:    2 ... konkrÃ©tnÄ›: ['ID', 'ITEM']
```

Z _DataFrame_ si lze pomocÃ­ `df.head(ğ‘›)` nechat vypsat prvnÃ­ch ğ‘› Å™Ã¡dkÅ¯ datovÃ© matice, vÃ½pis `df.head(10)` je totoÅ¾nÃ½ s nÃ¡hledem v Modeleru (viz prvnÃ­ obrÃ¡zek). DÃ¡le nÃ¡s zajÃ­mÃ¡, jakÃ½ch vÅ¡ech hodnot mÅ¯Å¾e nabÃ½vat sloupec `ITEM`, tedy jakÃ© kategorie zboÅ¾Ã­ (produktovÃ© skupiny) se v datech vyskytujÃ­. Tato informace se bude hodit i pozdÄ›ji pÅ™i tvorbÄ› pavuÄiÅˆÃ¡ku, proto si ji uloÅ¾Ã­me do promÄ›nnÃ© `ITEM_TYPES`.

```py
ITEM_TYPES = df["ITEM"].unique()
ITEM_TYPES
# array(['READMADE', 'SNACKS', 'TOILETRY', 'MILK', 'BAKERY', 'TINNED',
#        'FROZEN', 'ALCOHOL', 'VEG', 'MEAT'], dtype=object)
```

### Co se jak moc nakupuje?

Pandas umoÅ¾ÅˆujÃ­ snadno vizualizovat Äetnost jednotlivÃ½ch typÅ¯ zboÅ¾Ã­ v libovolnÃ©m nÃ¡kupnÃ­m koÅ¡Ã­ku.

```py
df["ITEM"].value_counts().plot(kind="bar")
```

![SloupcovÃ½ graf vyjadÅ™ujÃ­cÃ­ popularitu kategoriÃ­ zboÅ¾Ã­](./img/PlotBar.png)

MÅ¯Å¾eme vidÄ›t, Å¾e nejpopulÃ¡rnÄ›jÅ¡Ã­ kategoriÃ­ je `READMADE`. TÄ›snÄ› za `READMADE` se drÅ¾Ã­ ostatnÃ­ kategorie kromÄ› ÄtveÅ™ice `MILK`, `TOILETRY`, `VEG` a `MEAT`; kterÃ¡ je viditelnÄ› mÃ©nÄ› populÃ¡rnÃ­. Je dobrÃ© pÅ™ipomenout, Å¾e prozatÃ­m se zabÃ½vÃ¡me celkovÃ½m poÄtem prodanÃ½ch kusÅ¯ a nebereme v potaz kombinace zboÅ¾Ã­ v&nbsp;jednotlivÃ½ch koÅ¡Ã­cÃ­ch.

DÃ­ky knihovnÄ› _bokeh_ lze v prostÅ™edÃ­ Jupyter Notebook najet kurzorem myÅ¡i na jednotlivÃ© sloupce grafu a nechat si tak zobrazit pÅ™esnou hodnotu danÃ©ho sloupce. Pro procentuÃ¡lnÃ­ vyjÃ¡dÅ™enÃ­ popularity si lze upravit textovÃ½ vÃ½stup funkce `value_counts`.

```py
# `normalize=True` pÅ™evede na rozsah 0â€“1, pak vynÃ¡sobit stem, zaokrouhlit a pÅ™idat " %"
df["ITEM"].value_counts(normalize=True).mul(100).round(2).astype(str) + " %"
# READMADE    16.16 %
# SNACKS      15.57 %
# TINNED      14.95 %
# BAKERY      14.07 %
# FROZEN      13.19 %
# ALCOHOL     12.94 %
# MILK         6.18 %
# TOILETRY     3.26 %
# VEG          2.71 %
# MEAT         0.96 %
```

## PÅ™Ã­prava dat

### Restrukturalizace dat na pÅ™Ã­znaky

Pro algoritmy tvoÅ™Ã­cÃ­ asociaÄnÃ­ pravidla potÅ™ebujeme transakÄnÃ­ data pÅ™evÃ©st na tzv. tabulkovÃ¡ data, kde kaÅ¾dÃ½ Å™Ã¡dek reprezentuje jeden nÃ¡kupnÃ­ koÅ¡Ã­k. JednotlivÃ© sloupce jsou pojmenovanÃ© podle kategoriÃ­ zboÅ¾Ã­ a obsahujÃ­ dichotomickÃ© promÄ›nnÃ©, kterÃ© vyjadÅ™ujÃ­, zdali se danÃ¡ poloÅ¾ka v danÃ©m koÅ¡Ã­ku vyskytuje Äi nikoliv.

```py
# == Obdoba uzlu SetToFlag v SPSS Modeler ==
# get_dummies pÅ™evÃ¡dÃ­ kategoriÃ¡lnÃ­ data na pÅ™Ã­znakovÃ¡
# parametry: chceme pÅ™evÃ©st DataFrame df, v nÄ›m sloupec "ITEM", u vzniklÃ½ch sloupcÅ¯ nepÅ™idÃ¡vat Å¾Ã¡dnÃ½ prefix
# seskupujeme podle sloupce "ID" (jeden nÃ¡kup), po groupby musÃ­ pÅ™ijÃ­t agregaÄnÃ­ funkce â€“ suma nÃ¡m udÄ›lÃ¡ jedniÄky a nuly
flags = pd.get_dummies(df, columns=["ITEM"], prefix="", prefix_sep="").groupby(["ID"]).sum()
flags
```

ID|ALCOHOL|BAKERY|FROZEN|MEAT|MILK|READMADE|SNACKS|TINNED|TOILETRY|VEG
---|---|---|---|---|---|---|---|---|---|---
1.0|0|0|0|0|0|1|1|0|0|0
2.0|0|0|0|0|0|1|0|0|1|0
3.0|0|0|0|0|0|1|1|0|1|0
4.0|0|1|0|0|1|1|0|0|0|0
5.0|0|0|0|0|0|1|0|0|0|0
...|...|...|...|...|...|...|...|...|...|...

Pro splnÄ›nÃ­ prvnÃ­ho zadÃ¡nÃ­ se nÃ¡m bude hodit mnoÅ¾ina vÅ¡ech nÃ¡kupnÃ­ch koÅ¡Å¯, kterÃ© obsahujÃ­ alkohol, a proto si ji uloÅ¾Ã­me do promÄ›nnÃ© `flags_alcohol`.

```py
flags_alcohol = flags[flags["ALCOHOL"] == 1]
```

### PavuÄinovÃ½ diagram

Pro vykreslenÃ­ tabulkovÃ½ch dat, kterÃ© vyjadÅ™ujÃ­ spoleÄnÃ© typy zboÅ¾Ã­ v rÃ¡mci nÃ¡kupnÃ­ho koÅ¡Ã­ku, je moÅ¾nÃ© pouÅ¾Ã­t pavuÄinovÃ½ diagram. JelikoÅ¾ jsem nenaÅ¡el Å¾Ã¡dnou knihovnu, kterÃ¡ by tento typ grafu nativnÄ› podporovala, tak ho vykresluji â€ruÄnÄ›â€œ. JednÃ¡ se o obecnÃ½ graf z balÃ­ku _networkx_, kde definuji uzly (jejich souÅ™adnice a popisky) a hrany (mezi kterÃ½mi uzly vedou? jakÃ© majÃ­ ohodnocenÃ­?). Pro eliminaci opakujÃ­cÃ­ho se kÃ³du byla definovÃ¡na podpÅ¯rnÃ¡ funkce.

```py
def web(nodes, edges, edge_colors):
    graph = nx.Graph()

    # = Uzly grafu =
    # Pro kaÅ¾dÃ½ node pÅ™idÃ¡me jeden uzel do grafu a rozmÃ­stÃ­me je na pomyslnÃ© kruÅ¾nici (circular layout)
    graph.add_nodes_from(nodes)
    nodes_positions = nx.layout.circular_layout(graph)
    result_nodes = hvnx.draw_networkx_nodes(graph, nodes_positions, node_color="blue")

    # = Popisky uzlÅ¯ =
    # Dokumentace zmiÅˆuje nastavenÃ­ fontu u popiskÅ¯, bohuÅ¾el tyto parametry nic nedÄ›lajÃ­ (alespoÅˆ na mÃ© stranÄ›)
    # Proto jsou kvÅ¯li Äitelnosti popisky alespoÅˆ posunuty (v defaultu se nachÃ¡zÃ­ pÅ™Ã­mo na pozici uzlu, pÅ™ekrÃ½vÃ¡ se)
    # (O kolik posunout)
    LABEL_OFFSET = 0.1
    # (StejnÃ© souÅ™adnice jako uzly, jen je druhÃ¡ sloÅ¾ka posunuta o LABEL_OFFSET)
    label_posistions = {k: [v[0], v[1] + LABEL_OFFSET] for k, v in nodes_positions.items()}
    result_labels = hvnx.draw_networkx_labels(graph, label_posistions)

    # = Hrany a jejich barvy =
    graph.add_edges_from(edges)
    result_edges = hvnx.draw_networkx_edges(graph, nodes_positions, edge_color=edge_colors, colorbar=True)

    return result_nodes, result_labels, result_edges
```

* PodpÅ¯rnÃ¡ funkce mÃ¡ parametry:
  * Uzly `nodes` â€“ kolekce Å™etÄ›zcÅ¯
    * V naÅ¡em pÅ™Ã­padÄ› vÅ¾dy dosadÃ­me `ITEM_TYPES`, v grafu chceme mÃ­t vÅ¡echny kategorie zboÅ¾Ã­.
  * Hrany `edges` â€“ kolekce dvojic Å™etÄ›zcÅ¯ z `nodes`
  * OhodnocenÃ­ `edge_colors` â€“ kolekce ÄÃ­sel, kde kaÅ¾dÃ© ÄÃ­slo z `edge_colors[ğ‘–]` odpovÃ­dÃ¡ hranÄ› z `edges[ğ‘–]`.
    * Hodnota tÄ›chto ÄÃ­sel urÄuje obarvenÃ­ danÃ© hrany (analogie k tlouÅ¡Å¥ce ÄÃ¡ry v Modeleru).
* PodpÅ¯rnÃ¡ funkce vracÃ­ trojici (uzly, popisky, hrany) pro vykreslenÃ­.

#### PavuÄinovÃ½ diagram â€“ Alkohol

ProtoÅ¾e mÃ¡me datovou matici tvoÅ™enou jedniÄkami a nulami, mÅ¯Å¾eme seÄÃ­st vÅ¡echny jejÃ­ Å™Ã¡dky do jednoho a zjistit tak, jakÃ© typy zboÅ¾Ã­ se kolikrÃ¡t nachÃ¡zely v koÅ¡Ã­ku spoleÄnÄ› s alkoholem. (MomentÃ¡lnÄ› pracujeme s `flags_alcohol`, Å™eÅ¡Ã­me tedy pouze koÅ¡Ã­ky obsahujÃ­cÃ­ alkohol.)

```py
flags_alcohol_sum = flags_alcohol.sum()
flags_alcohol_sum
# ALCOHOL     310
# BAKERY      169
# FROZEN      181
# MEAT         16
# MILK         90
# READMADE    167
# SNACKS      172
# TINNED      136
# TOILETRY     47
# VEG          36

n_alcohol_connections = flags_alcohol_sum.sum() - flags_alcohol_sum["ALCOHOL"]
n_alcohol_connections
# 1014
```

NÃ¡kupÅ¯ obsahujÃ­cÃ­ch alkohol je 310, to odeÄteme od celkovÃ©ho poÄtu vÅ¡ech nakoupenÃ½ch poloÅ¾ek a dostÃ¡vÃ¡me 1014. JednÃ¡ se o poÄet poloÅ¾ek, kterÃ© se v libovolnÃ©m koÅ¡Ã­ku vyskytly spoleÄnÄ› s alkoholem. TÃ­mto ÄÃ­slem budeme dÄ›lit, abychom hrany pavuÄiÅˆÃ¡ku mohli vyjÃ¡dÅ™it procentuelnÄ›. Pro podpÅ¯rnou funkci je tÅ™eba popsat hrany a jejich barvy (ohodnocenÃ­).

```py
# Vedeme hranu z alkoholu do vÅ¡eho, co nenÃ­ alkohol.
edges = [(x, "ALCOHOL") for x in ITEM_TYPES if x != "ALCOHOL"]

# Pro kaÅ¾dou hranu (ğ‘¥, "ALCOHOL") zjistÃ­me poÄet poloÅ¾ek ze seÄtenÃ½ch Å™Ã¡dkÅ¯ pro hodnotu ğ‘¥
# a vydÄ›lÃ­me dÅ™Ã­ve spoÄtenÃ½m 1014. (Nakonec vynÃ¡sobit stovkou pro procenta.)
edge_colors = [flags_alcohol_sum[x[0]] / n_alcohol_connections * 100 for x in edges]

# PodpÅ¯rnÃ¡ funkce nÃ¡m vrÃ¡tÃ­ iformace o uzlech, popiscÃ­ch a hranÃ¡ch pro vykreslenÃ­
nodes, labels, edges = web(ITEM_TYPES, edges, edge_colors)

# Operace nÃ¡sobenÃ­ zde slouÅ¾Ã­ pro vykreslenÃ­ vÅ¡eho najednou (uzly, popisky a hrany grafu)
(nodes * labels * edges).opts(width=600, height=500)
```

![Graf Ã  la Modeler's Directed Web To Field ALCOHOL](./img/PlotWeb1.png)

Z grafu je dobÅ™e vidÄ›t, Å¾e s alkoholem je nejpopulÃ¡rnÄ›jÅ¡Ã­ nakupovat `FROZEN`, `SNACKS`, `BAKERY` a `READMADE`.

#### PavuÄinovÃ½ diagram â€“ VÅ¡e

Pro obecnÃ½ pavuÄiÅˆÃ¡k si pomocÃ­ _itertools_ vytvoÅ™Ã­me vÅ¡echny moÅ¾nÃ© dvojice kategoriÃ­ zboÅ¾Ã­ a pro kaÅ¾dou z nich spoÄteme Å™Ã¡dky pÅ™edstavujÃ­cÃ­ koÅ¡Ã­k, kterÃ½ obsahuje obÄ› poloÅ¾ky z dvojice. PomocÃ­ konstant `WEB_RANGE_MIN` a `WEB_RANGE_MAX` mÅ¯Å¾eme omezit rozsah vykreslovanÃ½ch ÄetnostÃ­.

```py
# Zobrazovat hrany v tomto rozsahu (obdoba posuvnÃ­ku v Modeleru)
WEB_RANGE_MIN = 0
WEB_RANGE_MAX = 250

item_pairs_all = list(itertools.combinations(ITEM_TYPES, 2))  # VÅ¡echny moÅ¾nÃ© dvojice

# Kolekce hran a jejich ohodnocenÃ­:
item_pairs = []  # Sem pÅ™idÃ¡me jen dvojice, kterÃ© vyhovujÃ­ rozsahu WEB_RANGE
item_pairs_quantities = []  # Sem pÅ™idÃ¡me ohodnocenÃ­ hran tÄ›chto dvojic

for pair in item_pairs_all:
    # `flags[(flags[pair[0]] == 1) & (flags[pair[1]] == 1)]` vracÃ­ takovÃ© Å™Ã¡dky, kde jsou obÄ› poloÅ¾ky z dvojice rovny jednÃ©
    # `len(df.index)` je preferovanÃ¡ metoda pro zjiÅ¡tÄ›nÃ­ poÄtu Å™Ã¡dku v pandas DataFrame
    quantity = len(flags[(flags[pair[0]] == 1) & (flags[pair[1]] == 1)].index)
    if WEB_RANGE_MIN <= quantity <= WEB_RANGE_MAX:
        # Pokud je poÄet vÃ½skytÅ¯ konkrÃ©tnÃ­ dvojice produktÅ¯ ve zvolenÃ©m rozsahu,
        # pÅ™idÃ¡me dvojici a kvantitu do item_pairs(_quantities), ze kterÃ½ch pak vykreslÃ­me pavuÄiÅˆÃ¡k.
        item_pairs.append(pair)
        item_pairs_quantities.append(quantity)

# VÃ½pis vÅ¡ech moÅ¾nÃ½ch dvojic zboÅ¾Ã­ a kolikrÃ¡t se spolu v koÅ¡Ã­ku vyskytly:
list(zip(item_pairs, item_pairs_quantities))
#[(('READMADE', 'SNACKS'), 192),
# (('READMADE', 'TOILETRY'), 46),
# (('READMADE', 'MILK'), 105),
# (('READMADE', 'BAKERY'), 201),
# (('READMADE', 'TINNED'), 170),
# ...
# (('ALCOHOL', 'MEAT'), 16),
# (('VEG', 'MEAT'), 7)]

# Vykreslit
nodes, labels, edges = web(ITEM_TYPES, item_pairs, item_pairs_quantities)
(nodes * labels * edges).opts(width=600, height=500)
```

![Graf Ã  la Modeler's Web â€kaÅ¾dÃ½ s kaÅ¾dÃ½mâ€œ](./img/PlotWeb2.png)

## ModelovÃ¡nÃ­ â€“ Apriori

Pro tvorbu asociaÄnÃ­ch pravidel je pouÅ¾it balÃ­k _mlxtend_.

```py
MINIMUM_ANTECEDENT_SUPPORT = 0.1
MINIMUM_RULE_CONFIDENCE = 0.60

# PouÅ¾itÃ¡ metoda preferuje dostat matici s bool promÄ›nnÃ½mi namÃ­sto jedniÄek a nul, pÅ™emapujeme
flags_bool = flags.map(bool)

# Do APRIORI dosadÃ­me datovout matici, minimÃ¡lnÃ­ support pÅ™edpokladÅ¯, a `use_colnames=True`
# Bez `use_colnames=True` by pravidla obsahovala ÄÃ­sla namÃ­sto nÃ¡zvÅ¯ zboÅ¾Ã­
item_frequencies = apriori(flags_bool, min_support=MINIMUM_ANTECEDENT_SUPPORT, use_colnames=True)

# Generace asociaÄnÃ­ch pravidel s minimÃ¡lnÃ­ confidence
# zahazuji sloupec representativity, protoÅ¾e je vÅ¡ude roven 1.0
# Å™adÃ­m podle confidence
a_rules = (
    association_rules(item_frequencies, metric="confidence", min_threshold=MINIMUM_RULE_CONFIDENCE)
    .drop(columns=["representativity"])
    .sort_values(by="confidence", ascending=False)
)

print("PoÄet pravidel:", len(a_rules.index))
a_rules
```

![57 vygenerovanÃ½ch Apriori pravidel](./img/AprioriRules1.png)

Pro prvnÃ­ ÄÃ¡st zadÃ¡nÃ­ si do promÄ›nnÃ© `a_rules_alcohol` uloÅ¾Ã­me jen ty pravidla, jejichÅ¾ zÃ¡vÄ›rem je alkohol.

```py
# Kolekce pÅ™edpokladÅ¯ a zÃ¡vÄ›rÅ¯ jsou typu frozenset; selekce pravidel, kde je zÃ¡vÄ›rem alkohol:
a_rules_alcohol = a_rules[a_rules["consequents"] == frozenset({"ALCOHOL"})]
a_rules_alcohol
```

![7 Apriori pravidel se zÃ¡vÄ›rem `ALCOHOL`](./img/AprioriRules2.png)

NynÃ­ tedy mÃ¡me vygenerovanÃ¡ pravidla s `MINIMUM_ANTECEDENT_SUPPORT` a `MINIMUM_RULE_CONFIDENCE` pro doporuÄenÃ­ alkoholu v akci a pro obecnÃ© doporuÄenÃ­ dalÅ¡Ã­ho typu zboÅ¾Ã­. Z tÄ›chto pravidel nynÃ­ vytvoÅ™Ã­me doporuÄovacÃ­ Python funkce, kterÃ© budeme moct evaluovat a nasadit.

### DoporuÄovacÃ­ funkce

#### DoporuÄovacÃ­ funkce pro alkohol

Pokud je zkoumanÃ½ nÃ¡kup nadmnoÅ¾inou nÄ›jakÃ© mnoÅ¾iny pÅ™edpokladÅ¯ pravidel, kterÃ© majÃ­ jako zÃ¡vÄ›r alkohol, a zÃ¡roveÅˆ zkoumanÃ½ nÃ¡kup alkohol jeÅ¡tÄ› neobsahuje, pak alkohol nabÃ­dneme. Funkce si bere jako parametry obsah koÅ¡Ã­ku (kolekce Å™etÄ›zcÅ¯) a seznam pravidel ve formÄ› _DataFrame_. Funkce vracÃ­ boolean True/False â€“ doporuÄit/nedoporuÄit.

```py
def recommend_alcohol(in_cart : list[str], rules : pd.DataFrame) -> bool:
    in_cart_set = set(in_cart)
    if "ALCOHOL" in in_cart_set:
        return False
    for _, row in rules.iterrows():
        # Na mnoÅ¾iny lze pouÅ¾Ã­vat operÃ¡tory <, >, <=, >= pro kontrolu podmnoÅ¾in/nadmnoÅ¾in
        if in_cart_set >= set(row["antecedents"]):
            return True
    return False
```

#### VÅ¡eobecnÃ¡ doporuÄovacÃ­ funkce

Tato funkce namÃ­sto boolean vracÃ­ seznam poloÅ¾ek, kterÃ© ke vstupnÃ­mu nÃ¡kupu jeÅ¡tÄ› doporuÄuje. PrvnÃ­ dva parametry jsou stejnÃ© (obsah koÅ¡Ã­ku a sada pravidel), tÅ™etÃ­ parametr urÄuje poÄet vÃ½stupnÃ­ch doporuÄenÃ­.

V tÃ©to funkci vybereme takovÃ¡ pravidla, pro kterÃ¡ platÃ­ platÃ­, Å¾e alespoÅˆ jeden z pÅ™edpokladÅ¯ musÃ­ bÃ½t ve zkoumanÃ©m koÅ¡Ã­ku a zÃ¡vÄ›r pravidla nesmÃ­ bÃ½t ve zkoumanÃ©m koÅ¡Ã­ku. Pokud jsou pravidla na vstupu seÅ™azenÃ¡ podle confidence, staÄÃ­ pak z vyhovujÃ­cÃ­ch pravidel zÃ­skat prvnÃ­ch ğ‘› unikÃ¡tnÃ­ch zÃ¡vÄ›rÅ¯ a ty vrÃ¡tit (kde ğ‘› je tÅ™etÃ­m parametrem, tedy poÄet doporuÄenÃ­).

```py
def recommend_something(in_cart : list[str], rules : pd.DataFrame, n_recommendations : int) -> list[str]:
    """
    [!] PoÄÃ­tÃ¡me s tÃ­m, Å¾e pravidla uÅ¾ jsou seÅ™azenÃ¡ podle confidence
    """
    recommendations = (rules[
        (rules["antecedents"].apply(lambda antecedents: any(product in antecedents for product in in_cart)))
        &
        (rules["consequents"].apply(lambda consequents: not any(product in consequents for product in in_cart)))
    ])
    result = []
    for _, row in recommendations.iterrows():
        for item in row["consequents"]:
            if item not in result:
                result.append(item)
    return result[:n_recommendations]
```

## Evaluace â€“ doporuÄenÃ­ alkoholu

Funkci pro doporuÄenÃ­ alkoholu lze evaluovat pomocÃ­ matice sousednosti. Pro jejÃ­ tvorbu jsem nevyuÅ¾il Å¾Ã¡dnÃ© knihovnÃ­ funkce, ale postupoval jsem metodou â€simple stupidâ€œ: PodÃ­vÃ¡m se v historii nÃ¡kupÅ¯ na vÅ¡echny sloupce kromÄ› alkoholu a podle pravidel urÄÃ­m, zdali bych alkohol danÃ©mu zÃ¡kaznÃ­kovi nabÃ­dl. Pak se podÃ­vÃ¡m na sloupec s alkoholem, zdali si ho tento zÃ¡kaznÃ­k skuteÄnÄ› koupil. Podle toho mÄ›Å™Ã­m kvalitu modelu.

```py
n_alcohol_recommended_correctly = 0        # True positive
n_alcohol_recommended_incorrectly = 0      # False positive
n_alcohol_not_recommended_correctly = 0    # True negative
n_alcohol_not_recommended_incorrectly = 0  # False negative

for _, row in flags.iterrows():
    # Row (pandas Series) bez sloupce s alkoholem je pÅ™eveden na slovnÃ­k stejnÄ› jako `in_my_cart_dict`
    row_cart = [k for k, v in row.drop(labels=["ALCOHOL"]).to_dict().items() if v == 1]
    # DoporuÄÃ­me zÃ¡kaznÃ­kovi alkohol?
    recommended_alcohol = recommend_alcohol(row_cart, a_rules_alcohol)
    # Koupil si zÃ¡kaznÃ­k skuteÄnÄ› alkohol?
    bought_alcohol = row["ALCOHOL"] == 1
    
    if recommended_alcohol:
        if bought_alcohol:
            n_alcohol_recommended_correctly += 1
        else:
            n_alcohol_recommended_incorrectly += 1
    else:
        if bought_alcohol:
            n_alcohol_not_recommended_incorrectly += 1
        else:
            n_alcohol_not_recommended_correctly += 1

# Matice zÃ¡mÄ›n: sloupce jsou klasifikace, Å™Ã¡dky jsou skuteÄnost
print("Alcohol\t  F\t  T")
print("     F \t", n_alcohol_not_recommended_correctly, "\t", n_alcohol_recommended_incorrectly)
print("     T \t", n_alcohol_not_recommended_incorrectly, "\t", n_alcohol_recommended_correctly)

# Alcohol       F       T
#      F       315     161
#      T       109     201
```

## NasazenÃ­

NasazenÃ­ simulujeme vytvoÅ™enÃ­m vlastnÃ­ho nÃ¡kupnÃ­ho koÅ¡Ã­ku a volÃ¡nÃ­m doporuÄovacÃ­ch funkcÃ­.

```py
# Analogie SPSS User Input; slovnÃ­k je pak pÅ™eveden na list obsahujÃ­cÃ­ klÃ­Äe, kde byla hodnota True
CUSTOMER_ID = 258
in_my_cart_dict = {
    'READMADE' : 1,
    'SNACKS'   : 0,
    'TOILETRY' : 0,
    'MILK'     : 0,
    'BAKERY'   : 0,
    'TINNED'   : 0,
    'FROZEN'   : 1,
    'ALCOHOL'  : 0,
    'VEG'      : 0,
    'MEAT'     : 1
}

in_my_cart = [k for k, v in in_my_cart_dict.items() if v == 1]
in_my_cart
# ['READMADE', 'FROZEN', 'MEAT']

recommend_result = recommend_alcohol(in_my_cart, a_rules_alcohol)
print(recommend_result, "â€“ Zakaznikovi", CUSTOMER_ID, "nabidni" if recommend_result else "nenabizej", "alkohol v akci.")
# True â€“ Zakaznikovi 258 nabidni alkohol v akci.

print("Zakaznikovi", CUSTOMER_ID, "nabidni:\n", recommend_something(in_my_cart, a_rules, 3))
# Zakaznikovi 258 nabidni:
#  ['BAKERY', 'ALCOHOL', 'SNACKS']
```

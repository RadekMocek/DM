# Anal√Ωza n√°kupn√≠ho ko≈°√≠ku

## Porozumƒõn√≠ probl√©mu

Obchodn√≠ ≈ôetƒõzec pot≈ôebuje analyzovat nakupovac√≠ n√°vyky sv√Ωch z√°kazn√≠k≈Ø, aby mohl prov√°dƒõt c√≠len√© nab√≠dky urƒçit√©ho typu zbo≈æ√≠. √öloha m√° dva c√≠le: vytvo≈ôit akci na prodej konkr√©tn√≠ho zbo≈æ√≠ (nab√≠dnout ƒçi nenab√≠dnout ‚Äì v na≈°em p≈ô√≠padƒõ se jedn√° o zbo≈æ√≠ typu alkohol) a vytvo≈ôit obecn√© doporuƒçen√≠, jak√© zbo≈æ√≠ z√°kazn√≠kovi je≈°tƒõ nab√≠dnout.

Soubor `Shopping_items.sav` p≈ôedstavuje transakƒçn√≠ data vznikaj√≠c√≠ p≈ôi pr≈Øchodu z√°kazn√≠ka pokladnou. Datov√° matice obsahuje promƒõnn√© `ID` a `ITEM`. `ID` je identifik√°tor jednoho konkr√©tn√≠ho n√°kupu a `ITEM` je druh zbo≈æ√≠, kter√Ω byl souƒç√°st√≠ tohoto n√°kupu. Vstupn√≠ data jsou zjednodu≈°ena t√≠m, ≈æe zbo≈æ√≠ je ji≈æ za≈ôazeno do produktov√Ωch skupin.

![N√°hled na vstupn√≠ data](./img/ShoppingItemsPreview.png)

## Prvn√≠ spu≈°tƒõn√≠ projektu

V ko≈ôenov√©m adres√°≈ôi projektu otev≈ôete PowerShell a spus≈•te n√°sleduj√≠c√≠ p≈ô√≠kazy:

```ps1
# 1. Vytvo≈ôen√≠ virtu√°ln√≠ho prost≈ôed√≠
py -m venv .venv

# 2. Aktivace virtu√°ln√≠ho prost≈ôed√≠
.venv\Scripts\activate

# 3. Nainstalov√°n√≠ pot≈ôebn√Ωch z√°vislost√≠
py -m pip install -r requirements.txt

# 4. Spu≈°tƒõn√≠ aplikace Jupyter Notebook v adres√°≈ôi s notebookem
jupyter notebook --notebook-dir=./notebook
```

Po naƒçten√≠ u≈æivatelsk√©ho rozhran√≠ aplikace Jupyter Notebook kliknƒõte na soubor _alza.ipynb_.

Pr√°ce ve virtu√°ln√≠m prost≈ôed√≠ je alespo≈à na m√©m PC ponƒõkud pomalej≈°√≠ (pomalej≈°√≠ instalace bal√≠k≈Ø, pomal√© naƒç√≠t√°n√≠ graf≈Ø, ...). Pokud v√°m nevad√≠ glob√°ln√≠ instalace bal√≠k≈Ø, pak staƒç√≠ dvojice p≈ô√≠kaz≈Ø `pip install -r requirements.txt` a `jupyter notebook --notebook-dir=./notebook`.

## Import z√°vislost√≠

Pro realizaci zad√°n√≠ je pou≈æita knihovna _pandas_. Do jej√≠ datov√© struktury zvan√© _DataFrame_ naƒçteme data ze vstupn√≠ho souboru `Shopping_items.sav` (bal√≠kem _pyreadstat_) a budeme na n√≠ prov√°dƒõt operace jako na datov√© matici v Modeleru.

Pro vizualizaci dat je pou≈æita kombinace _hvplot_ + _bokeh_. Jedn√≠m z vykreslovan√Ωch graf≈Ø je tzv. pavuƒçinov√Ω diagram (_Graphs ‚Üí Web_ v Modeleru, omluvte mnou obƒças pou≈æ√≠van√Ω krat≈°√≠ v√Ωraz ‚Äûpavuƒçi≈à√°k‚Äú), kter√Ω ale ≈æ√°dn√° mnou zkouman√° knihovna nativnƒõ nepodporuje. Pro jeho vlastn√≠ implementaci je proto pou≈æita knihovna _networkx_.

Modelovac√≠ algoritmus Apriori je obsa≈æen v bal√≠ku _mlxtend_.

```py
import itertools  # Vytvo≈ôen√≠ kombinac√≠, pom≈Ø≈æe p≈ôi tvorbƒõ pavuƒçi≈à√°ku
import pathlib    # K souboru .sav se dostaneme relativn√≠ cestou

import hvplot.networkx as hvnx  # Pavuƒçi≈à√°k
import networkx as nx           # Pavuƒçi≈à√°k
import pandas as pd             # Pr√°ce s datovou matic√≠ ‚Äì datov√° anal√Ωza v Pythonu
import pyreadstat               # ƒåten√≠ .sav souboru
from mlxtend.frequent_patterns import apriori, association_rules

pd.options.plotting.backend = "hvplot"  # Nam√≠sto matplotlib pou≈æ√≠v√°me hvplot + bokeh
```

## Porozumƒõn√≠ dat≈Øm

Transakƒçn√≠ data je nejrpve nutn√© naƒç√≠st, k tomu pou≈æijeme bal√≠k _pyreadstat_. Ne≈æ se vrhneme na samotnou datovou matici v podobƒõ _pandas DataFrame_, m≈Ø≈æeme vyƒç√≠st z metadat, ≈æe m√°me na vstupu 2395 ≈ô√°dk≈Ø a dva sloupce: `ID` a `ITEM`.

```py
# == Nalezen√≠ a naƒçten√≠ SPSS dat. Dost√°v√°me pandas DataFrame a metadata. ==
PATH = pathlib.Path()
PATH_SHOPPING_ITEMS = PATH / ".." / "data" / "Shopping_items.sav"
df, meta = pyreadstat.read_sav(PATH_SHOPPING_ITEMS)
print(type(df))
# <class 'pandas.core.frame.DataFrame'>
print(type(meta))
# <class 'pyreadstat._readstat_parser.metadata_container'>

# == U≈æiteƒçn√° metadata ==
print("Poƒçet ≈ô√°dk≈Ø:\t", meta.number_rows)
# Poƒçet ≈ô√°dk≈Ø:   2395
print("Poƒçet sloupc≈Ø:\t", meta.number_columns, "... konkr√©tnƒõ:", meta.column_names)
# Poƒçet sloupc≈Ø:    2 ... konkr√©tnƒõ: ['ID', 'ITEM']
```

Z _DataFrame_ si lze pomoc√≠ `df.head(ùëõ)` nechat vypsat prvn√≠ch ùëõ ≈ô√°dk≈Ø datov√© matice, v√Ωpis `df.head(10)` je toto≈æn√Ω s n√°hledem v Modeleru (viz prvn√≠ obr√°zek). D√°le n√°s zaj√≠m√°, jak√Ωch v≈°ech hodnot m≈Ø≈æe nab√Ωvat sloupec `ITEM`, tedy jak√© kategorie zbo≈æ√≠ (produktov√© skupiny) se v&nbsp;datech vyskytuj√≠. Tato informace se bude hodit i pozdƒõji p≈ôi tvorbƒõ pavuƒçi≈à√°ku, proto si ji ulo≈æ√≠me do promƒõnn√© `ITEM_TYPES`.

```py
ITEM_TYPES = df["ITEM"].unique()
ITEM_TYPES
# array(['READMADE', 'SNACKS', 'TOILETRY', 'MILK', 'BAKERY', 'TINNED',
#        'FROZEN', 'ALCOHOL', 'VEG', 'MEAT'], dtype=object)
```

### Co se jak moc nakupuje?

Pandas umo≈æ≈àuj√≠ snadno vizualizovat ƒçetnost jednotliv√Ωch typ≈Ø zbo≈æ√≠ v libovoln√©m n√°kupn√≠m ko≈°√≠ku.

```py
df["ITEM"].value_counts().plot(kind="bar")
```

![Sloupcov√Ω graf vyjad≈ôuj√≠c√≠ popularitu kategori√≠ zbo≈æ√≠](./img/PlotBar.png)

M≈Ø≈æeme vidƒõt, ≈æe nejpopul√°rnƒõj≈°√≠ kategori√≠ je `READMADE`. Tƒõsnƒõ za `READMADE` se dr≈æ√≠ ostatn√≠ kategorie kromƒõ ƒçtve≈ôice `MILK`, `TOILETRY`, `VEG` a `MEAT`; kter√° je viditelnƒõ m√©nƒõ popul√°rn√≠. Je dobr√© p≈ôipomenout, ≈æe prozat√≠m se zab√Ωv√°me celkov√Ωm poƒçtem prodan√Ωch kus≈Ø a nebereme v&nbsp;potaz kombinace zbo≈æ√≠ v&nbsp;jednotliv√Ωch ko≈°√≠c√≠ch.

D√≠ky knihovnƒõ _bokeh_ lze v prost≈ôed√≠ Jupyter Notebook najet kurzorem my≈°i na jednotliv√© sloupce grafu a nechat si tak zobrazit p≈ôesnou hodnotu dan√©ho sloupce. Pro procentu√°ln√≠ vyj√°d≈ôen√≠ popularity si lze upravit textov√Ω v√Ωstup funkce `value_counts`.

```py
# `normalize=True` p≈ôevede na rozsah 0‚Äì1, pak vyn√°sobit stem, zaokrouhlit a p≈ôidat " %"
df["ITEM"].value_counts(normalize=True).mul(100).round(2).astype(str) + " %"
# READMADE    16.16 %
# SNACKS      15.57 %
# TINNED      14.95 %
# BAKERY      14.07 %
# FROZEN      13.19 %
# ALCOHOL     12.94 %
# MILK         6.18 %
# TOILETRY     3.26 %
# VEG          2.71 %
# MEAT         0.96 %
```

## P≈ô√≠prava dat

### Restrukturalizace dat na p≈ô√≠znaky

Pro algoritmy tvo≈ô√≠c√≠ asociaƒçn√≠ pravidla pot≈ôebujeme transakƒçn√≠ data p≈ôev√©st na tzv. tabulkov√° data, kde ka≈æd√Ω ≈ô√°dek reprezentuje jeden n√°kupn√≠ ko≈°√≠k. Jednotliv√© sloupce jsou pojmenovan√© podle kategori√≠ zbo≈æ√≠ a obsahuj√≠ dichotomick√© promƒõnn√©, kter√© vyjad≈ôuj√≠, zdali se dan√° polo≈æka v&nbsp;dan√©m ko≈°√≠ku vyskytuje ƒçi nikoliv.

```py
# == Obdoba uzlu SetToFlag v SPSS Modeler ==
# get_dummies p≈ôev√°d√≠ kategori√°ln√≠ data na p≈ô√≠znakov√°
# parametry: chceme p≈ôev√©st DataFrame df, v nƒõm sloupec "ITEM", u vznikl√Ωch sloupc≈Ø nep≈ôid√°vat ≈æ√°dn√Ω prefix
# seskupujeme podle sloupce "ID" (jeden n√°kup), po groupby mus√≠ p≈ôij√≠t agregaƒçn√≠ funkce ‚Äì suma n√°m udƒõl√° jedniƒçky a nuly
flags = pd.get_dummies(df, columns=["ITEM"], prefix="", prefix_sep="").groupby(["ID"]).sum()
flags
```

ID|ALCOHOL|BAKERY|FROZEN|MEAT|MILK|READMADE|SNACKS|TINNED|TOILETRY|VEG
---|---|---|---|---|---|---|---|---|---|---
1.0|0|0|0|0|0|1|1|0|0|0
2.0|0|0|0|0|0|1|0|0|1|0
3.0|0|0|0|0|0|1|1|0|1|0
4.0|0|1|0|0|1|1|0|0|0|0
5.0|0|0|0|0|0|1|0|0|0|0
...|...|...|...|...|...|...|...|...|...|...

Pro splnƒõn√≠ prvn√≠ho zad√°n√≠ se n√°m bude hodit mno≈æina v≈°ech n√°kupn√≠ch ko≈°≈Ø, kter√© obsahuj√≠ alkohol, a proto si ji ulo≈æ√≠me do promƒõnn√© `flags_alcohol`.

```py
flags_alcohol = flags[flags["ALCOHOL"] == 1]
```

### Pavuƒçinov√Ω diagram

Pro vykreslen√≠ tabulkov√Ωch dat, kter√© vyjad≈ôuj√≠ spoleƒçn√© typy zbo≈æ√≠ v r√°mci n√°kupn√≠ho ko≈°√≠ku, je mo≈æn√© pou≈æ√≠t pavuƒçinov√Ω diagram. Jeliko≈æ jsem nena≈°el ≈æ√°dnou knihovnu, kter√° by tento typ grafu nativnƒõ podporovala, tak ho vykresluji ‚Äûruƒçnƒõ‚Äú. Jedn√° se o obecn√Ω graf z bal√≠ku _networkx_, kde definuji uzly (jejich sou≈ôadnice a popisky) a hrany (mezi kter√Ωmi uzly vedou? jak√© maj√≠ ohodnocen√≠?). Pro eliminaci opakuj√≠c√≠ho se k√≥du byla definov√°na podp≈Ørn√° funkce.

```py
def web(nodes, edges, edge_colors):
    graph = nx.Graph()

    # = Uzly grafu =
    # Pro ka≈æd√Ω node p≈ôid√°me jeden uzel do grafu a rozm√≠st√≠me je na pomysln√© kru≈ænici (circular layout)
    graph.add_nodes_from(nodes)
    nodes_positions = nx.layout.circular_layout(graph)
    result_nodes = hvnx.draw_networkx_nodes(graph, nodes_positions, node_color="blue")

    # = Popisky uzl≈Ø =
    # Dokumentace zmi≈àuje nastaven√≠ fontu u popisk≈Ø, bohu≈æel tyto parametry nic nedƒõlaj√≠ (alespo≈à na m√© stranƒõ)
    # Proto jsou kv≈Øli ƒçitelnosti popisky alespo≈à posunuty (v defaultu se nach√°z√≠ p≈ô√≠mo na pozici uzlu, p≈ôekr√Ωv√° se)
    # (O kolik posunout)
    LABEL_OFFSET = 0.1
    # (Stejn√© sou≈ôadnice jako uzly, jen je druh√° slo≈æka posunuta o LABEL_OFFSET)
    label_posistions = {k: [v[0], v[1] + LABEL_OFFSET] for k, v in nodes_positions.items()}
    result_labels = hvnx.draw_networkx_labels(graph, label_posistions)

    # = Hrany a jejich barvy =
    graph.add_edges_from(edges)
    result_edges = hvnx.draw_networkx_edges(graph, nodes_positions, edge_color=edge_colors, colorbar=True)

    return result_nodes, result_labels, result_edges
```

* Podp≈Ørn√° funkce m√° parametry:
  * Uzly `nodes` ‚Äì kolekce ≈ôetƒõzc≈Ø
    * V na≈°em p≈ô√≠padƒõ v≈ædy dosad√≠me `ITEM_TYPES`, v grafu chceme m√≠t v≈°echny kategorie zbo≈æ√≠.
  * Hrany `edges` ‚Äì kolekce dvojic ≈ôetƒõzc≈Ø z `nodes`
  * Ohodnocen√≠ `edge_colors` ‚Äì kolekce ƒç√≠sel, kde ka≈æd√© ƒç√≠slo z `edge_colors[ùëñ]` odpov√≠d√° hranƒõ z `edges[ùëñ]`.
    * Hodnota tƒõchto ƒç√≠sel urƒçuje obarven√≠ dan√© hrany (analogie k tlou≈°≈•ce ƒç√°ry v Modeleru).
* Podp≈Ørn√° funkce vrac√≠ trojici (uzly, popisky, hrany) pro vykreslen√≠.

#### Pavuƒçinov√Ω diagram ‚Äì Alkohol

Proto≈æe m√°me datovou matici tvo≈ôenou jedniƒçkami a nulami, m≈Ø≈æeme seƒç√≠st v≈°echny jej√≠ ≈ô√°dky do jednoho a zjistit tak, jak√© typy zbo≈æ√≠ se kolikr√°t nach√°zely v ko≈°√≠ku spoleƒçnƒõ s alkoholem. (Moment√°lnƒõ pracujeme s `flags_alcohol`, ≈ôe≈°√≠me tedy pouze ko≈°√≠ky obsahuj√≠c√≠ alkohol.)

```py
flags_alcohol_sum = flags_alcohol.sum()
flags_alcohol_sum
# ALCOHOL     310
# BAKERY      169
# FROZEN      181
# MEAT         16
# MILK         90
# READMADE    167
# SNACKS      172
# TINNED      136
# TOILETRY     47
# VEG          36

n_alcohol_connections = flags_alcohol_sum.sum() - flags_alcohol_sum["ALCOHOL"]
n_alcohol_connections
# 1014
```

N√°kup≈Ø obsahuj√≠c√≠ch alkohol je 310, to odeƒçteme od celkov√©ho poƒçtu v≈°ech nakoupen√Ωch polo≈æek a dost√°v√°me 1014. Jedn√° se o poƒçet polo≈æek, kter√© se v libovoln√©m ko≈°√≠ku vyskytly spoleƒçnƒõ s alkoholem. T√≠mto ƒç√≠slem budeme dƒõlit, abychom hrany pavuƒçi≈à√°ku mohli vyj√°d≈ôit procentuelnƒõ. Pro podp≈Ørnou funkci je t≈ôeba popsat hrany a jejich barvy (ohodnocen√≠).

```py
# Vedeme hranu z alkoholu do v≈°eho, co nen√≠ alkohol.
edges = [(x, "ALCOHOL") for x in ITEM_TYPES if x != "ALCOHOL"]

# Pro ka≈ædou hranu (ùë•, "ALCOHOL") zjist√≠me poƒçet polo≈æek ze seƒçten√Ωch ≈ô√°dk≈Ø pro hodnotu ùë•
# a vydƒõl√≠me d≈ô√≠ve spoƒçten√Ωm 1014. (Nakonec vyn√°sobit stovkou pro procenta.)
edge_colors = [flags_alcohol_sum[x[0]] / n_alcohol_connections * 100 for x in edges]

# Podp≈Ørn√° funkce n√°m vr√°t√≠ iformace o uzlech, popisc√≠ch a hran√°ch pro vykreslen√≠
nodes, labels, edges = web(ITEM_TYPES, edges, edge_colors)

# Operace n√°soben√≠ zde slou≈æ√≠ pro vykreslen√≠ v≈°eho najednou (uzly, popisky a hrany grafu)
(nodes * labels * edges).opts(width=600, height=500)
```

![Graf √† la Modeler's Directed Web To Field ALCOHOL](./img/PlotWeb1.png)

Z grafu je dob≈ôe vidƒõt, ≈æe s alkoholem je nejpopul√°rnƒõj≈°√≠ nakupovat `FROZEN`, `SNACKS`, `BAKERY` a `READMADE`.

#### Pavuƒçinov√Ω diagram ‚Äì V≈°e

Pro obecn√Ω pavuƒçi≈à√°k si pomoc√≠ _itertools_ vytvo≈ô√≠me v≈°echny mo≈æn√© dvojice kategori√≠ zbo≈æ√≠ a pro ka≈ædou z nich spoƒçteme ≈ô√°dky p≈ôedstavuj√≠c√≠ ko≈°√≠k, kter√Ω obsahuje obƒõ polo≈æky z dvojice. Pomoc√≠ konstant `WEB_RANGE_MIN` a `WEB_RANGE_MAX` m≈Ø≈æeme omezit rozsah vykreslovan√Ωch ƒçetnost√≠.

```py
# Zobrazovat hrany v tomto rozsahu (obdoba posuvn√≠ku v Modeleru)
WEB_RANGE_MIN = 0
WEB_RANGE_MAX = 250

item_pairs_all = list(itertools.combinations(ITEM_TYPES, 2))  # V≈°echny mo≈æn√© dvojice

# Kolekce hran a jejich ohodnocen√≠:
item_pairs = []  # Sem p≈ôid√°me jen dvojice, kter√© vyhovuj√≠ rozsahu WEB_RANGE
item_pairs_quantities = []  # Sem p≈ôid√°me ohodnocen√≠ hran tƒõchto dvojic

for pair in item_pairs_all:
    # `flags[(flags[pair[0]] == 1) & (flags[pair[1]] == 1)]` vrac√≠ takov√© ≈ô√°dky, kde jsou obƒõ polo≈æky z dvojice rovny jedn√©
    # `len(df.index)` je preferovan√° metoda pro zji≈°tƒõn√≠ poƒçtu ≈ô√°dku v pandas DataFrame
    quantity = len(flags[(flags[pair[0]] == 1) & (flags[pair[1]] == 1)].index)
    if WEB_RANGE_MIN <= quantity <= WEB_RANGE_MAX:
        # Pokud je poƒçet v√Ωskyt≈Ø konkr√©tn√≠ dvojice produkt≈Ø ve zvolen√©m rozsahu,
        # p≈ôid√°me dvojici a kvantitu do item_pairs(_quantities), ze kter√Ωch pak vykresl√≠me pavuƒçi≈à√°k.
        item_pairs.append(pair)
        item_pairs_quantities.append(quantity)

# V√Ωpis v≈°ech mo≈æn√Ωch dvojic zbo≈æ√≠ a kolikr√°t se spolu v ko≈°√≠ku vyskytly:
list(zip(item_pairs, item_pairs_quantities))
#[(('READMADE', 'SNACKS'), 192),
# (('READMADE', 'TOILETRY'), 46),
# (('READMADE', 'MILK'), 105),
# (('READMADE', 'BAKERY'), 201),
# (('READMADE', 'TINNED'), 170),
# ...
# (('ALCOHOL', 'MEAT'), 16),
# (('VEG', 'MEAT'), 7)]

# Vykreslit
nodes, labels, edges = web(ITEM_TYPES, item_pairs, item_pairs_quantities)
(nodes * labels * edges).opts(width=600, height=500)
```

![Graf √† la Modeler's Web ‚Äûka≈æd√Ω s ka≈æd√Ωm‚Äú](./img/PlotWeb2.png)

## Modelov√°n√≠ ‚Äì Apriori

Pro tvorbu asociaƒçn√≠ch pravidel je pou≈æit bal√≠k _mlxtend_.

```py
MINIMUM_ANTECEDENT_SUPPORT = 0.1
MINIMUM_RULE_CONFIDENCE = 0.60

# Pou≈æit√° metoda preferuje dostat matici s bool promƒõnn√Ωmi nam√≠sto jedniƒçek a nul, p≈ôemapujeme
flags_bool = flags.map(bool)

# Do APRIORI dosad√≠me datovout matici, minim√°ln√≠ support p≈ôedpoklad≈Ø, a `use_colnames=True`
# Bez `use_colnames=True` by pravidla obsahovala ƒç√≠sla nam√≠sto n√°zv≈Ø zbo≈æ√≠
item_frequencies = apriori(flags_bool, min_support=MINIMUM_ANTECEDENT_SUPPORT, use_colnames=True)

# Generace asociaƒçn√≠ch pravidel s minim√°ln√≠ confidence
# zahazuji sloupec representativity, proto≈æe je v≈°ude roven 1.0
# ≈ôad√≠m podle confidence
a_rules = (
    association_rules(item_frequencies, metric="confidence", min_threshold=MINIMUM_RULE_CONFIDENCE)
    .drop(columns=["representativity"])
    .sort_values(by="confidence", ascending=False)
)

print("Poƒçet pravidel:", len(a_rules.index))
a_rules
```

![57 vygenerovan√Ωch Apriori pravidel](./img/AprioriRules1.png)

Pro prvn√≠ ƒç√°st zad√°n√≠ si do promƒõnn√© `a_rules_alcohol` ulo≈æ√≠me jen ty pravidla, jejich≈æ z√°vƒõrem je alkohol.

```py
# Kolekce p≈ôedpoklad≈Ø a z√°vƒõr≈Ø jsou typu frozenset; selekce pravidel, kde je z√°vƒõrem alkohol:
a_rules_alcohol = a_rules[a_rules["consequents"] == frozenset({"ALCOHOL"})]
a_rules_alcohol
```

![7 Apriori pravidel se z√°vƒõrem `ALCOHOL`](./img/AprioriRules2.png)

Nyn√≠ tedy m√°me vygenerovan√° pravidla s `MINIMUM_ANTECEDENT_SUPPORT` a `MINIMUM_RULE_CONFIDENCE` pro doporuƒçen√≠ alkoholu v akci a pro obecn√© doporuƒçen√≠ dal≈°√≠ho typu zbo≈æ√≠. Z tƒõchto pravidel nyn√≠ vytvo≈ô√≠me doporuƒçovac√≠ Python funkce, kter√© budeme moct evaluovat a nasadit.

### Doporuƒçovac√≠ funkce

#### Doporuƒçovac√≠ funkce pro alkohol

Pokud je zkouman√Ω n√°kup nadmno≈æinou nƒõjak√© mno≈æiny p≈ôedpoklad≈Ø pravidel, kter√© maj√≠ jako z√°vƒõr alkohol, a z√°rove≈à zkouman√Ω n√°kup alkohol je≈°tƒõ neobsahuje, pak alkohol nab√≠dneme. Funkce si bere jako parametry obsah ko≈°√≠ku (kolekce ≈ôetƒõzc≈Ø) a seznam pravidel ve formƒõ _DataFrame_. Funkce vrac√≠ boolean True/False ‚Äì doporuƒçit/nedoporuƒçit.

```py
def recommend_alcohol(in_cart : list[str], rules : pd.DataFrame) -> bool:
    in_cart_set = set(in_cart)
    if "ALCOHOL" in in_cart_set:
        return False
    for _, row in rules.iterrows():
        # Na mno≈æiny lze pou≈æ√≠vat oper√°tory <, >, <=, >= pro kontrolu podmno≈æin/nadmno≈æin
        if in_cart_set >= set(row["antecedents"]):
            return True
    return False
```

#### V≈°eobecn√° doporuƒçovac√≠ funkce

Tato funkce nam√≠sto boolean vrac√≠ seznam polo≈æek, kter√© ke vstupn√≠mu n√°kupu je≈°tƒõ doporuƒçuje. Prvn√≠ dva parametry jsou stejn√© (obsah ko≈°√≠ku a sada pravidel), t≈ôet√≠ parametr urƒçuje poƒçet v√Ωstupn√≠ch doporuƒçen√≠.

V t√©to funkci vybereme takov√° pravidla, pro kter√° plat√≠, ≈æe alespo≈à jeden z p≈ôedpoklad≈Ø mus√≠ b√Ωt ve zkouman√©m ko≈°√≠ku a z√°vƒõr pravidla nesm√≠ b√Ωt ve zkouman√©m ko≈°√≠ku. Pokud jsou pravidla na vstupu se≈ôazen√° podle confidence, staƒç√≠ pak z vyhovuj√≠c√≠ch pravidel z√≠skat prvn√≠ch ùëõ unik√°tn√≠ch z√°vƒõr≈Ø a ty vr√°tit (kde ùëõ je t≈ôet√≠m parametrem, tedy poƒçet doporuƒçen√≠).

```py
def recommend_something(in_cart : list[str], rules : pd.DataFrame, n_recommendations : int) -> list[str]:
    """
    [!] Poƒç√≠t√°me s t√≠m, ≈æe pravidla u≈æ jsou se≈ôazen√° podle confidence
    """
    recommendations = (rules[
        (rules["antecedents"].apply(lambda antecedents: any(product in antecedents for product in in_cart)))
        &
        (rules["consequents"].apply(lambda consequents: not any(product in consequents for product in in_cart)))
    ])
    result = []
    for _, row in recommendations.iterrows():
        for item in row["consequents"]:
            if item not in result:
                result.append(item)
    return result[:n_recommendations]
```

## Evaluace ‚Äì doporuƒçen√≠ alkoholu

Funkci pro doporuƒçen√≠ alkoholu lze evaluovat pomoc√≠ matice sousednosti. Pro jej√≠ tvorbu jsem nevyu≈æil ≈æ√°dn√© knihovn√≠ funkce, ale postupoval jsem metodou ‚Äûsimple stupid‚Äú: Pod√≠v√°m se v&nbsp;historii n√°kup≈Ø na v≈°echny sloupce kromƒõ alkoholu a podle pravidel urƒç√≠m, zdali bych alkohol dan√©mu z√°kazn√≠kovi nab√≠dl. Pak se pod√≠v√°m na sloupec s alkoholem, zdali si ho tento z√°kazn√≠k skuteƒçnƒõ koupil. Podle toho mƒõ≈ô√≠m kvalitu modelu.

```py
n_alcohol_recommended_correctly = 0        # True positive
n_alcohol_recommended_incorrectly = 0      # False positive
n_alcohol_not_recommended_correctly = 0    # True negative
n_alcohol_not_recommended_incorrectly = 0  # False negative

for _, row in flags.iterrows():
    # Row (pandas Series) bez sloupce s alkoholem je p≈ôeveden na slovn√≠k (stejnƒõ jako `in_my_cart_dict` v sekci nasazen√≠)
    row_cart = [k for k, v in row.drop(labels=["ALCOHOL"]).to_dict().items() if v == 1]
    # Doporuƒç√≠me z√°kazn√≠kovi alkohol?
    recommended_alcohol = recommend_alcohol(row_cart, a_rules_alcohol)
    # Koupil si z√°kazn√≠k skuteƒçnƒõ alkohol?
    bought_alcohol = row["ALCOHOL"] == 1
    
    if recommended_alcohol:
        if bought_alcohol:
            n_alcohol_recommended_correctly += 1
        else:
            n_alcohol_recommended_incorrectly += 1
    else:
        if bought_alcohol:
            n_alcohol_not_recommended_incorrectly += 1
        else:
            n_alcohol_not_recommended_correctly += 1

# Matice z√°mƒõn: sloupce jsou klasifikace, ≈ô√°dky jsou skuteƒçnost
print("Alcohol\t  F\t  T")
print("     F \t", n_alcohol_not_recommended_correctly, "\t", n_alcohol_recommended_incorrectly)
print("     T \t", n_alcohol_not_recommended_incorrectly, "\t", n_alcohol_recommended_correctly)

# Alcohol       F       T
#      F       315     161
#      T       109     201
```

Ze v≈°ech 786 n√°kup≈Ø bychom spr√°vnƒõ 315kr√°t nenab√≠dli a 201kr√°t nab√≠dli alkohol v akci. Co se t√Ωƒçe chyb, tak m√°me 161 ‚Äûzbyteƒçn√Ωch nab√≠dek‚Äú a 109 ‚Äûpromarnƒõn√Ωch p≈ô√≠le≈æitost√≠‚Äú.

Z hodnot matice z√°mƒõn pak lze spoƒç√≠tat dal≈°√≠ kvantifik√°tory:

```py
# Zjednodu≈°en√≠ n√°zv≈Ø
TP, FP, TN, FN = (n_alcohol_recommended_correctly,
                  n_alcohol_recommended_incorrectly,
                  n_alcohol_not_recommended_correctly,
                  n_alcohol_not_recommended_incorrectly)

print("Celkova spravnost =", (TP+TN)/(TP+FP+TN+FN))
print("    Celkova chyba =", (FP+FN)/(TP+FP+TN+FN))
print("         Presnost =", TP/(TP+FP))
print("      Senzitivita =", TP/(TP+FN))
print("     Specificnost =", TN/(TN+FP))
# Celkova spravnost = 0.6564885496183206
#     Celkova chyba = 0.3435114503816794
#          Presnost = 0.5552486187845304
#       Senzitivita = 0.6483870967741936
#      Specificnost = 0.6617647058823529
```

## Nasazen√≠

Nasazen√≠ simulujeme vytvo≈ôen√≠m vlastn√≠ho n√°kupn√≠ho ko≈°√≠ku a vol√°n√≠m doporuƒçovac√≠ch funkc√≠.

```py
# == Analogie SPSS User Input ==
CUSTOMER_ID = 258
in_my_cart_dict = {
    'READMADE' : 1,
    'SNACKS'   : 0,
    'TOILETRY' : 0,
    'MILK'     : 0,
    'BAKERY'   : 0,
    'TINNED'   : 0,
    'FROZEN'   : 1,
    'ALCOHOL'  : 0,
    'VEG'      : 0,
    'MEAT'     : 1
}

# Slovn√≠k je p≈ôeveden na list obsahuj√≠c√≠ kl√≠ƒçe, kde byla hodnota rovna jedn√©
in_my_cart = [k for k, v in in_my_cart_dict.items() if v == 1]
in_my_cart
# ['READMADE', 'FROZEN', 'MEAT']

# == Nasazen√≠ doporuƒçen√≠ alkoholu ==
recommend_result = recommend_alcohol(in_my_cart, a_rules_alcohol)
print(recommend_result, "‚Äì Zakaznikovi", CUSTOMER_ID, "nabidni" if recommend_result else "nenabizej", "alkohol v akci.")
# True ‚Äì Zakaznikovi 258 nabidni alkohol v akci.

# == Nasazen√≠ obecn√©ho doporuƒçen√≠ ==
print("Zakaznikovi", CUSTOMER_ID, "nabidni:\n", recommend_something(in_my_cart, a_rules, 3))
# Zakaznikovi 258 nabidni:
#  ['BAKERY', 'ALCOHOL', 'SNACKS']
```
